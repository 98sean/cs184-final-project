<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 10%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184 Summer 2025 Final Project Milestone Deliverables</h1>
		<div style="text-align: center;">Project Name: Ambient Global Illumination with Caching</div>	
		<div style="text-align: center;">Members: Xin Zhou, Sean Lee, Archisha Nangia, Carlynda Gao</div>

		<br>
		<a href="https://98sean.github.io/cs184-final-project/milestone/index.html">Link to webpage</a>
		
		<br>
		<a href="https://github.com/98sean/cs184-final-project">Link to GitHub repository</a>

		<br>
		<a href="https://drive.google.com/file/d/17j2J4o59Nf3lxjc2iARp6NVTCGqcfLeb/view?usp=drive_link">Link to presentation video</a>

		<br>
		<a href="https://drive.google.com/open?id=1pRmVCR8a5XRdqP-jEiae39sMD_ODIUFopG1kRiPUGBM&usp=drive_copy">Link to presentation slides</a>




			
		<h2>Milestone Report</h2>
				
		<p>
		Following our proposal and the feedback, we studied Greg Ward's paper on the ambient caching algorithm and implemented our initial grid-based cache system. Then, we compared the performance with the standard Monte Carlo approach in HW3. In this stage, we have the following components:
		</p>

		<ul>
            		<li>
                	<strong>Grid-based Spatial Cache:</strong> We utilize a uniform 3D grid structure for storing ambient lighting values. Each cache entry contains position, surface normal, and the computed ambient radiance value.
            		</li>
			
            		<li>
                	<strong>Cache Lookup with Simple Interpolation:</strong> The ambient cache is integrated into the indirect lighting computation. In <code>at_least_one_bounce_radiance()</code>, we first attempt to retrieve cached values. On cache misses, ambient lighting is computed using 256 hemisphere samples and the result is stored. Cache hits retrieve values using inverse distance weighted interpolation from nearby entries.
            		</li>
			
            		<li>
               	 	<strong>Cache Visualization:</strong> We developed a visualization system that renders cache points as colored spheres, with color indicating ambient intensity (blue = low, green = medium, red = high). This aids in understanding cache distribution and debugging grid spacing parameters.
            		</li>
			
            		<li>
                	<strong>Command Line Parameter:</strong> A <code>-g</code> flag has been added to enable ambient Global Illumination (GI) mode, allowing for comparisons with standard Monte Carlo rendering.
            		</li>
        	</ul>

		<figure style="text-align: center; margin: 1em 0;">
  			<img src="grid_based.jpg" alt="grid_based.jpg" style="width: 100%">
  			<figcaption style="margin-top: 0.5em;"><em>Figure 1:</em> 
			Grid-based caching and inverse distance weighted interpolation
  			</figcaption>
		</figure>

		<p>
		As shown in <em>Figure 1</em>, when rays hit surfaces, we either reuse cached values or compute new ones.
		</p>

		<figure style="text-align: center; margin: 1em 0;">
  			<img src="comparison.jpg" alt="comparison.jpg" style="width: 100%">
  			<figcaption style="margin-top: 0.5em;"><em>Figure 2:</em> 
			Images rendered with Ambient GI caching
  			</figcaption>
		</figure>

		<p>
		As shown in <em>Figure 2</em>, we tested 0.5, 1.0, 1.5, and 2.0 grid spacing and found that caching can effectively achieve rendering speedups. However, it produces color patches and artifacts in the image. Compared to the reference image with Monte Carlo, caching loses the smooth lighting gradients effect. We will address these limitations by implementing Ward's algorithm, including gradient computation for proper cache validation and potentially transitioning to an octree, KD tree, or 3D hash table for adaptive spatial subdivision. This should significantly improve visual quality while maintaining the performance benefits demonstrated in this milestone.
		</p>
		



			
		</div>
	</body>
</html>
